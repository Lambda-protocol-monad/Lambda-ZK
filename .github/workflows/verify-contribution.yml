name: Verify Ceremony Contribution

on:
  pull_request_target: # Required for auto-merge from forks with write permissions
    branches: ['main']
    types: [opened, synchronize, reopened]
    paths:
      - 'ceremony/contrib/**/*.zkey'
      - 'ceremony/output/**/*.zkey' # Also trigger for aggregation PRs

permissions:
  contents: write # Required for merge
  pull-requests: write # Required for comments and merge
  actions: write # Required for workflow operations
  checks: write # Required for check runs

# Serialize contribution PRs to prevent race conditions
concurrency:
  group: contribution-verification
  cancel-in-progress: false

jobs:
  verify:
    runs-on: ubuntu-latest
    # Skip verification for PRs created by the ceremony bot (aggregation PRs)
    # limit this to only the bot user if needed, but we actually WANT this to run for aggregation PRs
    # so they satisfy the "verify" status check.
    # We will handle the logic inside the steps to skip strict checks for aggregation.
    if: github.event.pull_request.user.login != 'github-actions[bot]' || startsWith(github.event.pull_request.head.ref, 'ceremony-aggregate-')

    steps:
      - name: Checkout PR head from base repo
        uses: actions/checkout@v4
        with:
          # CRITICAL: Check out the PR's head commit, but DO NOT execute any code from it
          # We only validate the .zkey file (binary data), never execute PR code
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0
          submodules: false

      - name: Identify PR Type
        id: pr_type
        shell: bash
        run: |
          if [[ "${{ github.event.pull_request.head.ref }}" == ceremony-aggregate-* ]]; then
            echo "IS_AGGREGATION=true" >> "$GITHUB_OUTPUT"
            echo "‚úÖ Identified as Aggregation PR"
          else
            echo "IS_AGGREGATION=false" >> "$GITHUB_OUTPUT"
            echo "‚ÑπÔ∏è Identified as Standard Contribution PR"
          fi

      - name: Check if ceremony is already finalized
        shell: bash
        run: |
          set -euo pipefail

          echo "üîç Checking if ceremony has been finalized..."

          # Check for final ceremony artifacts on main branch
          git fetch origin main

          if git ls-tree origin/main ceremony/output/ | grep -q "giftcard_merkle_final.zkey"; then
            echo "‚ùå CEREMONY ALREADY FINALIZED"
            echo ""
            echo "This ceremony has been finalized and is no longer accepting contributions."
            echo "The final proving and verification keys have been generated and are production-ready."
            echo ""
            echo "Final artifacts:"
            echo "  - ceremony/output/giftcard_merkle_final.zkey"
            echo "  - ceremony/output/giftcard_merkle_verification_key.json"
            echo ""
            echo "No further contributions can be accepted."
            exit 1
          fi

          echo "‚úÖ Ceremony is still open for contributions"

      - name: Enforce strict file change validation for contribution PR
        id: strict_validation
        if: steps.pr_type.outputs.IS_AGGREGATION == 'false'
        shell: bash
        run: |
          set -euo pipefail

          echo "üìù Enforcing strict file change validation..."

          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"

          # Use name-status to ensure NOTHING except exactly one added zkey is present.
          # --no-renames: Force git to see similar files as separate add/delete, not renames
          CHANGED_FILES=$(git diff --name-status --no-renames "$BASE_SHA" "$HEAD_SHA")
          echo "Detected changes:"
          echo "$CHANGED_FILES"

          ADDED_COUNT=0
          FOUND_VALID_ZKEY_ADDITION=false
          ADDED_ZKEY_PATH=""

          # Process all changes
          while IFS=$'\t' read -r STATUS FILE REST; do
            # Skip empty lines (git diff output can sometimes contain them)
            [[ -z "${STATUS:-}" ]] && continue

            case "$STATUS" in
              A)
                # Check if this is a valid zkey addition
                if [[ "$FILE" =~ ^ceremony/contrib/giftcard_merkle_[0-9]+\.zkey$ ]]; then
                  echo "‚úÖ Found valid added .zkey file (numbered format): $FILE"
                  FOUND_VALID_ZKEY_ADDITION=true
                  ADDED_ZKEY_PATH="$FILE"
                  ADDED_COUNT=$((ADDED_COUNT + 1))
                elif [[ "$FILE" =~ ^ceremony/contrib/giftcard_merkle_tmp_[0-9_]+\.zkey$ ]]; then
                  echo "‚úÖ Found valid added .zkey file (temporary format): $FILE"
                  echo "‚ÑπÔ∏è  This contribution will be automatically renumbered by the aggregation workflow"
                  FOUND_VALID_ZKEY_ADDITION=true
                  ADDED_ZKEY_PATH="$FILE"
                  ADDED_COUNT=$((ADDED_COUNT + 1))
                else
                  echo "‚ùå Error: New file added at an invalid location or with an invalid name: $FILE"
                  echo "   Expected format: ceremony/contrib/giftcard_merkle_NNNN.zkey OR ceremony/contrib/giftcard_merkle_tmp_*.zkey"
                  exit 1
                fi
                ;;
              D)
                # Allow deletion of .zkey files in contrib/ (cleanup from previous tests)
                if [[ "$FILE" =~ ^ceremony/contrib/.*\.zkey$ ]]; then
                  echo "‚ÑπÔ∏è  Ignoring deletion of old contribution file: $FILE"
                else
                  echo "‚ùå Error: Contribution PRs must not delete non-contribution files. Found DELETE for: $FILE"
                  exit 1
                fi
                ;;
              M)
                echo "‚ùå Error: Contribution PRs must not modify files. Found MODIFY for: $FILE"
                exit 1
                ;;
              R*|C*)
                # Renames/copies should not appear with --no-renames, but just in case
                echo "‚ùå Error: Renames/copies are not allowed in contribution PRs. Found $STATUS for: $FILE ${REST:-}"
                exit 1
                ;;
              *)
                echo "‚ùå Error: Unhandled/unsupported change type ($STATUS) for file: $FILE ${REST:-}"
                exit 1
                ;;
            esac
          done <<< "$CHANGED_FILES"

          if ! $FOUND_VALID_ZKEY_ADDITION; then
            echo "‚ùå Error: Did not find a valid new zkey file addition."
            echo "   Expected: ceremony/contrib/giftcard_merkle_NNNN.zkey (numbered)"
            echo "        OR: ceremony/contrib/giftcard_merkle_tmp_*.zkey (temporary)"
            exit 1
          fi

          if [ "$ADDED_COUNT" -ne 1 ]; then
            echo "‚ùå Error: Expected exactly one file addition, but found $ADDED_COUNT."
            exit 1
          fi

          echo "‚úÖ Strict file change validation passed."

          echo "ADDED_ZKEY_PATH=$ADDED_ZKEY_PATH" >> "$GITHUB_OUTPUT"

      - name: Security checks (symlinks, submodules, LFS)
        if: steps.pr_type.outputs.IS_AGGREGATION == 'false'
        shell: bash
        run: |
          set -euo pipefail

          echo "üîí Performing security checks..."

          HEAD_SHA="${{ github.event.pull_request.head.sha }}"

          # Check for symlinks (120000) and submodules (160000)
          if git ls-tree -r "$HEAD_SHA" | grep -E '^(120000|160000)'; then
            echo "‚ùå Security violation: Symlinks or submodules are not allowed"
            exit 1
          fi

          # Verify file size (must be > 100KB, typical zkey is ~5-6MB)
          ZKEY_FILE="${{ steps.strict_validation.outputs.ADDED_ZKEY_PATH }}"
          FILE_SIZE=$(stat -c%s "$ZKEY_FILE" 2>/dev/null || stat -f%z "$ZKEY_FILE" 2>/dev/null)

          if [ "$FILE_SIZE" -lt 102400 ]; then
            echo "‚ùå File too small ($FILE_SIZE bytes). Expected ~5-6MB. Might be LFS pointer."
            exit 1
          fi

          echo "‚úÖ Security checks passed. File size: $FILE_SIZE bytes"

      - name: Restore PTAU from cache
        if: steps.pr_type.outputs.IS_AGGREGATION == 'false'
        uses: actions/cache@v4
        with:
          path: circuits/ptau/powersOfTau28_hez_final_18.ptau
          key: ptau-${{ runner.os }}-powersOfTau28_hez_final_18-v1

      - name: Setup Node.js
        if: steps.pr_type.outputs.IS_AGGREGATION == 'false'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install snarkjs (pinned)
        if: steps.pr_type.outputs.IS_AGGREGATION == 'false'
        run: |
          npm install -g snarkjs@0.7.5
          snarkjs --version || true

      - name: Ensure PTAU file
        if: steps.pr_type.outputs.IS_AGGREGATION == 'false'
        shell: bash
        run: |
          set -euo pipefail

          PTAU_PATH="circuits/ptau/powersOfTau28_hez_final_18.ptau"
          mkdir -p circuits/ptau

          if [ ! -f "$PTAU_PATH" ]; then
            echo "üîÑ Downloading PTAU file..."
            curl -L --max-time 600 --retry 3 --retry-delay 10 \
              "https://storage.googleapis.com/zkevm/ptau/powersOfTau28_hez_final_18.ptau" \
              -o "$PTAU_PATH"

            if [ ! -s "$PTAU_PATH" ]; then
              echo "‚ùå PTAU download failed"
              rm -f "$PTAU_PATH"
              exit 1
            fi
          fi

          # Verify PTAU checksum
          PTAU_CHECKSUM=$(sha256sum "$PTAU_PATH" | awk '{print $1}')
          EXPECTED="e970efa7774da80101e0ac336d083ef3339855c98112539338d706b2b89ac694"

          if [ "$PTAU_CHECKSUM" != "$EXPECTED" ]; then
            echo "‚ùå PTAU checksum mismatch!"
            echo "   Expected: $EXPECTED"
            echo "   Got:      $PTAU_CHECKSUM"
            exit 1
          fi

          echo "‚úÖ PTAU verified"

      - name: Install circom
        if: steps.pr_type.outputs.IS_AGGREGATION == 'false'
        shell: bash
        run: |
          set -euo pipefail
          curl -L https://github.com/iden3/circom/releases/download/v2.1.9/circom-linux-amd64 \
            -o /usr/local/bin/circom
          chmod +x /usr/local/bin/circom
          circom --version || true

      - name: Compile giftcard_merkle circuit
        if: steps.pr_type.outputs.IS_AGGREGATION == 'false'
        shell: bash
        run: |
          set -euo pipefail
          echo "üî® Compiling giftcard_merkle circuit..."
          mkdir -p circuits/build
          circom circuits/giftcard_merkle.circom --r1cs --wasm -o circuits/build

          if [ ! -f "circuits/build/giftcard_merkle.r1cs" ]; then
            echo "‚ùå Circuit compilation failed - R1CS not generated"
            exit 1
          fi

          echo "‚úÖ Circuit compiled successfully"
          ls -lh circuits/build/giftcard_merkle.r1cs

      - name: Verify contribution cryptographically (snarkjs zkey verify)
        id: crypto_verify
        if: steps.pr_type.outputs.IS_AGGREGATION == 'false'
        shell: bash
        run: |
          set -euo pipefail

          echo "üîê Verifying contribution with snarkjs..."

          PTAU_PATH="circuits/ptau/powersOfTau28_hez_final_18.ptau"
          R1CS_PATH="circuits/build/giftcard_merkle.r1cs"
          NEW_ZKEY="${{ steps.strict_validation.outputs.ADDED_ZKEY_PATH }}"

          if [ ! -f "$PTAU_PATH" ] || [ ! -f "$R1CS_PATH" ] || [ ! -f "$NEW_ZKEY" ]; then
            echo "‚ùå Missing required files for verification"
            exit 1
          fi

          echo "  R1CS: $R1CS_PATH"
          echo "  PTAU: $PTAU_PATH"
          echo "  NEW:  $NEW_ZKEY"

          # This verifies the zkey is valid for (R1CS, PTAU).
          if ! timeout 300 snarkjs zkey verify "$R1CS_PATH" "$PTAU_PATH" "$NEW_ZKEY"; then
            echo "‚ùå Cryptographic verification FAILED"
            exit 1
          fi

          echo "‚úÖ snarkjs zkey verify succeeded for contribution."

      - name: Validate parent zkey (prevent non-sequential contributions)
        if: steps.pr_type.outputs.IS_AGGREGATION == 'false'
        shell: bash
        run: |
          set -euo pipefail

          echo "üîç Validating that contribution is based on latest ceremony state..."

          ZKEY_FILE="${{ steps.strict_validation.outputs.ADDED_ZKEY_PATH }}"

          # Get latest zkey from output/
          if ls ceremony/output/giftcard_merkle_*.zkey >/dev/null 2>&1; then
            LATEST_OUTPUT=$(ls -1 ceremony/output/giftcard_merkle_*.zkey | sort -V | tail -n1)
            echo "üìä Latest output zkey: $LATEST_OUTPUT"

            # Calculate hash of the latest zkey (this should be the parent)
            EXPECTED_PARENT_HASH=$(sha256sum "$LATEST_OUTPUT" | awk '{print $1}')
            echo "üìä Expected parent hash (last chain zkey): ${EXPECTED_PARENT_HASH:0:16}..."

            # Use snarkjs to get contribution index
            # The contribution metadata includes the index which tells us how many contributions
            # have been applied. We verify this matches our expected chain length.
            echo "üîç Extracting contribution metadata..."

            # Get the number of existing contributions in output/
            EXISTING_CONTRIBS=$(find ceremony/output -name "giftcard_merkle_[0-9][0-9][0-9][0-9].zkey" | wc -l)
            # Subtract 1 because 0000.zkey is the initial setup, not a contribution
            EXPECTED_CONTRIB_INDEX=$((EXISTING_CONTRIBS - 1))

            echo "üìä Existing zkeys in output/: $EXISTING_CONTRIBS"
            echo "üìä Expected contribution index: $EXPECTED_CONTRIB_INDEX"

            # Export contribution info
            snarkjs zkey export json "$ZKEY_FILE" /tmp/contrib_check.json

            # Check if the zkey has contributions field
            if jq -e '.contributions' /tmp/contrib_check.json > /dev/null 2>&1; then
              ACTUAL_CONTRIB_COUNT=$(jq '.contributions | length' /tmp/contrib_check.json)
              echo "üìä Actual contributions in submitted zkey: $ACTUAL_CONTRIB_COUNT"

              # The submitted zkey should have exactly EXPECTED_CONTRIB_INDEX + 1 contributions
              # (the +1 is the new contribution being submitted)
              EXPECTED_TOTAL_CONTRIBS=$((EXPECTED_CONTRIB_INDEX + 1))

              if [ "$ACTUAL_CONTRIB_COUNT" -eq "$EXPECTED_TOTAL_CONTRIBS" ]; then
                echo "‚úÖ Contribution count matches expected chain length"
                echo "   This contribution properly extends the ceremony chain"
              else
                echo "‚ùå VALIDATION FAILED: Contribution index mismatch!"
                echo "   Expected contributions: $EXPECTED_TOTAL_CONTRIBS"
                echo "   Actual contributions: $ACTUAL_CONTRIB_COUNT"
                echo ""
                echo "This means the contribution was NOT based on the latest ceremony state."
                echo "Please download the latest zkey from ceremony/output/ and regenerate your contribution."
                echo ""
                echo "Latest zkey to use: $LATEST_OUTPUT"
                exit 1
              fi
            else
              echo "‚ö†Ô∏è Warning: Could not extract contribution metadata"
              echo "   Proceeding with cryptographic verification only"
            fi

            echo "‚úÖ Parent zkey validation passed"
            echo "   Contribution is based on latest ceremony state"
          else
            echo "‚ÑπÔ∏è  No existing output zkeys found. This might be the first contribution."
          fi

      - name: Rate limiting check (anti-spam)
        if: steps.pr_type.outputs.IS_AGGREGATION == 'false'
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          AUTHOR="${{ github.event.pull_request.user.login }}"

          echo "üîç Checking rate limits for user: $AUTHOR"

          # Check if user is a repository owner or collaborator (skip rate limits for them)
          USER_PERMISSION=$(gh api /repos/${{ github.repository }}/collaborators/$AUTHOR/permission --jq '.permission' 2>/dev/null || echo "none")

          echo "User permission level: $USER_PERMISSION"

          if [[ "$USER_PERMISSION" == "admin" || "$USER_PERMISSION" == "write" ]]; then
            echo "‚úÖ User is a repository collaborator/owner - skipping rate limits"
            exit 0
          fi

          echo "‚ÑπÔ∏è  Applying contribution limit for external contributor"

          # Count ALL merged PRs from this author (lifetime contributions to ceremony)
          # This ensures each participant can only contribute ONCE to maintain ceremony integrity
          TOTAL_CONTRIBS=$(gh pr list \
            --repo ${{ github.repository }} \
            --author "$AUTHOR" \
            --state merged \
            --json number \
            --jq 'length' || echo "0")

          echo "Total contributions from $AUTHOR: $TOTAL_CONTRIBS"

          if [ "$TOTAL_CONTRIBS" -ge 1 ]; then
            echo "‚ùå Contribution limit exceeded: Maximum 1 contribution per participant"
            echo "   Each participant can only contribute once to the ceremony"
            echo "   This maintains the cryptographic security properties of the trusted setup"
            exit 1
          fi

          echo "‚úÖ First contribution from this participant"

          # Check account age (must be > 7 days)
          ACCOUNT_CREATED=$(gh api /users/$AUTHOR --jq '.created_at')
          ACCOUNT_AGE_SECONDS=$(( $(date +%s) - $(date -d "$ACCOUNT_CREATED" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$ACCOUNT_CREATED" +%s) ))
          ACCOUNT_AGE_DAYS=$(( ACCOUNT_AGE_SECONDS / 86400 ))

          echo "Account age: $ACCOUNT_AGE_DAYS days"

          if [ "$ACCOUNT_AGE_DAYS" -lt 7 ]; then
            echo "‚ùå Account too new. Please wait $((7 - ACCOUNT_AGE_DAYS)) more days before contributing."
            exit 1
          fi

          echo "‚úÖ Rate limit checks passed"

      - name: Auto-pass for Aggregation PR
        if: steps.pr_type.outputs.IS_AGGREGATION == 'true'
        run: |
          echo "‚úÖ Aggregation PR detected - skipping specific contribution checks"
          echo "   Usage of the 'verify' workflow to satisfy branch protection rules."
          echo "   The composition was already verified by the aggregate-ceremony workflow."

      - name: Post success comment
        if: success() && steps.pr_type.outputs.IS_AGGREGATION == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: `## ‚úÖ Contribution Verified Successfully

            **Cryptographic Verification:** PASSED ‚úì
            **Security Checks:** PASSED ‚úì
            **Parent Zkey Validation:** PASSED ‚úì
            **Contribution Limit:** PASSED ‚úì

            ### Next Steps
            Auto-merge has been enabled for this PR. It will be **automatically merged** once all branch protection requirements are met.

            After merge, the aggregation workflow will:
            1. Process your contribution into the official ceremony chain
            2. Update the output directory with verified artifacts
            3. Generate updated checksums and manifests

            Thank you for contributing to the ceremony! üéâ

            ---
            *Automated verification by Lambda-ZK Ceremony*`
            });

      - name: Approve verified contribution
        if: success() && steps.pr_type.outputs.IS_AGGREGATION == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.payload.pull_request.number;

            console.log(`‚úÖ All validations passed - approving PR #${prNumber}`);

            // Post approval comment
            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              event: 'APPROVE',
              body: `‚úÖ Contribution cryptographically verified and approved.

            **Verification Summary:**
            - ‚úÖ Cryptographic validation passed
            - ‚úÖ Security checks passed
            - ‚úÖ Parent zkey validation passed
            - ‚úÖ Contribution limit checks passed

            **Next Steps:**
            This PR will be automatically merged once all status checks complete.
            The aggregation workflow will then process this contribution and update the ceremony chain.

            ---
            ü§ñ Automated verification by Lambda-ZK Ceremony`
            });

            console.log(`‚úÖ PR #${prNumber} approved successfully`);

      - name: Post failure comment
        if: failure() && steps.pr_type.outputs.IS_AGGREGATION == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: `## ‚ùå Contribution Verification Failed

            One or more validation checks failed. Please review the workflow logs for details.

            ### Common issues:
            - **Cryptographic verification failed**: Ensure you used the latest zkey from \`ceremony/output/\` as input
            - **File validation failed**: Make sure you added exactly one \`.zkey\` file in \`ceremony/contrib/\`
            - **Contribution limit exceeded**: Maximum 1 contribution per participant
            - **Account too new**: Account must be at least 7 days old

            ### How to fix:
            1. Review the [workflow run logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            2. Fix the issue locally
            3. Force-push to this PR branch to re-trigger verification

            ---
            *Automated verification by Lambda-ZK Ceremony*`
            });

  merge:
    runs-on: ubuntu-latest
    needs: verify
    if: success()

    steps:
      - name: Merge verified contribution
        uses: actions/github-script@v7
        env:
          BYPASS_TOKEN: ${{ secrets.BYPASS_TOKEN }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.payload.pull_request.number;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const bypassToken = process.env.BYPASS_TOKEN;

            console.log('üîÄ Attempting to merge PR...');
            
            // Helper to merge using specific token via fetch
            async function mergeWithToken(token) {
              const url = `https://api.github.com/repos/${owner}/${repo}/pulls/${prNumber}/merge`;
              const response = await fetch(url, {
                method: 'PUT',
                headers: {
                  'Authorization': `token ${token}`,
                  'Accept': 'application/vnd.github.v3+json',
                  'Content-Type': 'application/json',
                  'User-Agent': 'actions/github-script'
                },
                body: JSON.stringify({
                  merge_method: 'squash',
                  commit_title: `Ceremony contribution #${prNumber}`,
                  commit_message: `‚úÖ Cryptographically verified contribution\n\nAutomated merge by Lambda-ZK Ceremony\n\nVerification Summary:\n- Cryptographic validation: PASSED\n- Security checks: PASSED\n- Parent zkey validation: PASSED\n- Contribution limit: PASSED\n\nWorkflow run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`
                })
              });
              
              if (!response.ok) {
                const data = await response.json();
                throw new Error(data.message || response.statusText);
              }
              return await response.json();
            }

            try {
              let merged = false;
              let mergeData = null;

              // 1. Try BYPASS_TOKEN if available
              if (bypassToken) {
                console.log('üîë BYPASS_TOKEN detected. Attempting privileged merge...');
                try {
                  mergeData = await mergeWithToken(bypassToken);
                  console.log('‚úÖ PR merged successfully using BYPASS_TOKEN');
                  merged = true;
                } catch (bypassError) {
                  console.log('‚ö†Ô∏è Merge with BYPASS_TOKEN failed:', bypassError.message);
                  console.log('üîÑ Falling back to GITHUB_TOKEN...');
                }
              }

              // 2. Fallback to default GITHUB_TOKEN (via standard Octokit client) if not yet merged
              if (!merged) {
                const result = await github.rest.pulls.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  merge_method: 'squash',
                  commit_title: `Ceremony contribution #${prNumber}`,
                  commit_message: `‚úÖ Cryptographically verified contribution\n\nAutomated merge by Lambda-ZK Ceremony\n\nVerification Summary:\n- Cryptographic validation: PASSED\n- Security checks: PASSED\n- Parent zkey validation: PASSED\n- Contribution limit: PASSED\n\nWorkflow run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`
                });
                mergeData = result.data;
                console.log('‚úÖ PR merged successfully using GITHUB_TOKEN');
              }

              console.log(`   SHA: ${mergeData.sha}`);
              console.log(`   Merged: ${mergeData.merged}`);

              // Delete the branch (optional, for cleanup)
              try {
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `heads/${context.payload.pull_request.head.ref}`
                });
                console.log('‚úÖ Branch deleted');
              } catch (deleteError) {
                console.log('‚ÑπÔ∏è  Could not delete branch (may be from fork):', deleteError.message);
              }

            } catch (mergeError) {
              console.error('‚ùå Failed to merge PR:', mergeError.message);

              // Post a comment about the merge failure
              // This call uses the default 'github' client which is now guaranteed to be GITHUB_TOKEN
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `‚ö†Ô∏è **Automatic merge failed**\n\nYour contribution has been **approved** and passed all security checks, but automatic merge failed.\n\n**Error:** ${mergeError.message}\n\n**Action Required:**\nA repository maintainer needs to manually merge this PR.\n\n---\nü§ñ Automated verification by Lambda-ZK Ceremony`
              });

              throw mergeError; // Fail the workflow
            }
