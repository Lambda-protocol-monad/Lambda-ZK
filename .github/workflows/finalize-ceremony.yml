name: Finalize Ceremony (Beacon)

on:
  workflow_dispatch:
    inputs:
      drand_round:
        description: 'Precommitted drand round number (choose in advance; do NOT change after publishing)'
        required: true
        type: string
  schedule:
    # Run once a day at midnight UTC (as a safety net). It will no-op if already finalized.
    - cron: '0 0 * * *'

permissions:
  contents: write
  pull-requests: write

# Prevent multiple finalization workflows from running simultaneously
# This ensures only one finalization can happen at a time
concurrency:
  group: ceremony-finalization
  cancel-in-progress: false # Queue instead of canceling

jobs:
  finalize:
    runs-on: ubuntu-latest
    outputs:
      has_changes: ${{ steps.finalize_status.outputs.HAS_CHANGES }}
      pr_number: ${{ steps.create_pr.outputs.pull-request-number }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Restore PTAU from cache
        uses: actions/cache@v4
        with:
          path: circuits/ptau/powersOfTau28_hez_final_18.ptau
          key: ptau-${{ runner.os }}-powersOfTau28_hez_final_18-v1

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install snarkjs (pinned)
        run: |
          npm install -g snarkjs@0.7.5
          snarkjs --version || true

      - name: Ensure PTAU file
        shell: bash
        run: |
          set -euo pipefail
          PTAU_PATH="circuits/ptau/powersOfTau28_hez_final_18.ptau"
          mkdir -p circuits/ptau
          if [ ! -f "$PTAU_PATH" ]; then
            echo "PTAU not found in cache, downloading..."
            curl -L "https://storage.googleapis.com/zkevm/ptau/powersOfTau28_hez_final_18.ptau" -o "$PTAU_PATH"
            echo "‚úÖ PTAU downloaded"
          else
            echo "‚úÖ PTAU restored from cache"
          fi

      - name: Determine drand round
        id: drand
        shell: bash
        run: |
          set -euo pipefail

          if [ -n "${{ github.event.inputs.drand_round || '' }}" ]; then
            ROUND="${{ github.event.inputs.drand_round }}"
            echo "Using workflow_dispatch drand_round: $ROUND"
          elif [ -n "${{ vars.DRAND_ROUND || '' }}" ]; then
            ROUND="${{ vars.DRAND_ROUND }}"
            echo "Using repo variable DRAND_ROUND: $ROUND"
          else
            echo "‚ùå No drand round provided."
            echo "   Provide it via manual dispatch input 'drand_round',"
            echo "   or set a repo variable named DRAND_ROUND."
            exit 1
          fi

          if ! [[ "$ROUND" =~ ^[0-9]+$ ]]; then
            echo "‚ùå drand_round must be a number. Got: $ROUND"
            exit 1
          fi

          echo "ROUND=$ROUND" >> "$GITHUB_OUTPUT"

      - name: Install circom
        shell: bash
        run: |
          set -euo pipefail
          CIRCOM_VERSION=2.1.9
          curl -L -o /tmp/circom-linux-amd64 "https://github.com/iden3/circom/releases/download/v${CIRCOM_VERSION}/circom-linux-amd64"
          chmod +x /tmp/circom-linux-amd64
          sudo mv /tmp/circom-linux-amd64 /usr/local/bin/circom
          circom --version

      - name: Compile circuit to R1CS
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p circuits/build
          circom circuits/giftcard_merkle.circom --r1cs --wasm -o circuits/build
          test -f circuits/build/giftcard_merkle.r1cs

      - name: Install system deps (curl, jq)
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y curl jq
          jq --version
          curl --version

      - name: Run final beacon script
        shell: bash
        run: |
          set -euo pipefail
          ./ceremony/scripts/final_beacon.sh "${{ steps.drand.outputs.ROUND }}"

      - name: Verify finalization artifacts
        shell: bash
        run: |
          set -euo pipefail

          echo "üîç Verifying finalization artifacts..."

          FINAL_ZKEY="ceremony/output/giftcard_merkle_final.zkey"
          FINAL_VKEY="ceremony/output/giftcard_merkle_verification_key.json"

          # Check if finalization already happened (idempotency)
          if [ ! -f "$FINAL_ZKEY" ]; then
            echo "‚ÑπÔ∏è  Final zkey not generated (ceremony may already be finalized)"
            exit 0
          fi

          echo "‚úÖ Final zkey exists: $FINAL_ZKEY"

          # Verify checksums were generated
          if [ ! -f "$FINAL_ZKEY.sha256" ]; then
            echo "‚ùå Missing checksum file: $FINAL_ZKEY.sha256"
            exit 1
          fi

          if [ ! -f "$FINAL_VKEY" ]; then
            echo "‚ùå Missing verification key: $FINAL_VKEY"
            exit 1
          fi

          if [ ! -f "$FINAL_VKEY.sha256" ]; then
            echo "‚ùå Missing checksum file: $FINAL_VKEY.sha256"
            exit 1
          fi

          echo "‚úÖ All finalization artifacts present"

          # Verify file sizes are reasonable
          ZKEY_SIZE=$(stat -c%s "$FINAL_ZKEY" 2>/dev/null || stat -f%z "$FINAL_ZKEY" 2>/dev/null)
          if [ "$ZKEY_SIZE" -lt 100000 ]; then
            echo "‚ùå Final zkey suspiciously small: $ZKEY_SIZE bytes"
            exit 1
          fi

          echo "‚úÖ Final zkey size: $ZKEY_SIZE bytes"
          echo "‚úÖ Finalization verification complete"

      - name: Check if finalization produced changes
        id: finalize_status
        shell: bash
        run: |
          set -euo pipefail

          # Check if finalization produced new files (use git status for untracked files)
          if [ -z "$(git status --porcelain ceremony/output/giftcard_merkle_final.zkey ceremony/output/giftcard_merkle_verification_key.json 2>/dev/null)" ]; then
            echo "‚ÑπÔ∏è  No changes detected (ceremony already finalized)"
            echo "HAS_CHANGES=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "‚úÖ Finalization artifacts detected"
          echo "HAS_CHANGES=true" >> "$GITHUB_OUTPUT"

      - name: Create Pull Request for ceremony finalization
        id: create_pr
        if: steps.finalize_status.outputs.HAS_CHANGES == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: |
            [CEREMONY] Finalize with public randomness beacon

            üéØ Drand Round: ${{ steps.drand.outputs.ROUND }}
            üîê Beacon Source: https://api.drand.sh/public/${{ steps.drand.outputs.ROUND }}
            ‚ö° Auto-generated by Lambda-ZK Ceremony Finalization

            Final artifacts:
            - ceremony/output/giftcard_merkle_final.zkey
            - ceremony/output/giftcard_merkle_verification_key.json

            The ceremony is now complete and production-ready.
            Toxic waste has been eliminated via public randomness beacon.
          branch: ceremony-finalize-${{ github.run_id }}
          delete-branch: true
          title: '[CEREMONY] Finalize with drand beacon (round ${{ steps.drand.outputs.ROUND }})'
          body: |
            ## üéØ Ceremony Finalization

            This PR finalizes the trusted setup ceremony using public randomness from drand.

            ### Finalization Details
            - **Drand Round**: `${{ steps.drand.outputs.ROUND }}`
            - **Beacon Source**: https://api.drand.sh/public/${{ steps.drand.outputs.ROUND }}
            - **Workflow Run**: [#${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

            ### Final Artifacts Generated
            - ‚úÖ `ceremony/output/giftcard_merkle_final.zkey` - Production proving key
            - ‚úÖ `ceremony/output/giftcard_merkle_final.zkey.sha256` - Checksum
            - ‚úÖ `ceremony/output/giftcard_merkle_verification_key.json` - Verification key
            - ‚úÖ `ceremony/output/giftcard_merkle_verification_key.json.sha256` - Checksum

            ### Verification Steps Completed
            1. ‚úÖ Public randomness fetched from drand
            2. ‚úÖ Beacon hash derived via SHA-256
            3. ‚úÖ Applied to ceremony chain via `snarkjs zkey beacon`
            4. ‚úÖ Final zkey verified against R1CS and PTAU
            5. ‚úÖ Verification key exported
            6. ‚úÖ SHA-256 checksums generated

            ### Security Properties
            - **Toxic Waste Elimination**: ‚úÖ COMPLETE
            - **Public Randomness**: Verifiable via drand API
            - **Adversarial Security**: Maintained throughout ceremony
            - **Production Ready**: ‚úÖ Final keys are secure for production use

            ### Review Checklist
            - [ ] Verify drand round matches expected precommitment
            - [ ] Confirm randomness is publicly verifiable on drand
            - [ ] Check final artifact checksums
            - [ ] Verify no unexpected files modified

            ### Next Steps
            1. **Review** the finalization artifacts
            2. **Verify** drand randomness independently: `curl https://api.drand.sh/public/${{ steps.drand.outputs.ROUND }}`
            3. **Approve and merge** to complete the ceremony
            4. **Announce** ceremony completion to community

            ---
            üéâ **The ceremony is complete!** Merging this PR marks the official end of the trusted setup.

            The final proving and verification keys are now production-ready for the giftcard_merkle circuit.
          labels: |
            ceremony
            finalization
            critical
            automated
          add-paths: |
            ceremony/output/giftcard_merkle_final.zkey
            ceremony/output/giftcard_merkle_final.zkey.sha256
            ceremony/output/giftcard_merkle_verification_key.json
            ceremony/output/giftcard_merkle_verification_key.json.sha256

      - name: Post PR creation comment
        if: steps.create_pr.outputs.pull-request-number
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ steps.create_pr.outputs.pull-request-number }},
              body: `‚úÖ **Ceremony finalization PR created**

            **Drand Round:** ${{ steps.drand.outputs.ROUND }}
            **Beacon Source:** https://api.drand.sh/public/${{ steps.drand.outputs.ROUND }}

            This PR will be automatically merged to complete the ceremony.

            ---
            ü§ñ Automated finalization by Lambda-ZK Ceremony`
            });

  merge:
    runs-on: ubuntu-latest
    needs: finalize
    if: needs.finalize.outputs.has_changes == 'true'
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Merge finalization PR
        uses: actions/github-script@v7
        env:
          BYPASS_TOKEN: ${{ secrets.BYPASS_TOKEN }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = ${{ needs.finalize.outputs.pr_number }};
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const bypassToken = process.env.BYPASS_TOKEN;

            console.log('üîÄ Attempting to merge Finalization PR...');

            // Helper to merge using specific token via fetch
            async function mergeWithToken(token) {
              const url = `https://api.github.com/repos/${owner}/${repo}/pulls/${prNumber}/merge`;
              const response = await fetch(url, {
                method: 'PUT',
                headers: {
                  'Authorization': `token ${token}`,
                  'Accept': 'application/vnd.github.v3+json',
                  'Content-Type': 'application/json',
                  'User-Agent': 'actions/github-script'
                },
                body: JSON.stringify({
                  merge_method: 'squash',
                  commit_title: `Ceremony Finalization`,
                  commit_message: `‚úÖ Ceremony Finalized\n\nAutomated merge by Lambda-ZK Ceremony`
                })
              });
              
              if (!response.ok) {
                const data = await response.json();
                throw new Error(data.message || response.statusText);
              }
              return await response.json();
            }

            try {
              let merged = false;

              // 1. Try BYPASS_TOKEN if available
              if (bypassToken) {
                console.log('üîë BYPASS_TOKEN detected. Attempting privileged merge...');
                try {
                  await mergeWithToken(bypassToken);
                  console.log('‚úÖ PR merged successfully using BYPASS_TOKEN');
                  merged = true;
                } catch (bypassError) {
                  console.log('‚ö†Ô∏è Merge with BYPASS_TOKEN failed:', bypassError.message);
                  console.log('üîÑ Falling back to GITHUB_TOKEN...');
                }
              }

              // 2. Fallback to default GITHUB_TOKEN
              if (!merged) {
                await github.rest.pulls.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  merge_method: 'squash',
                  commit_title: `Ceremony Finalization`,
                  commit_message: `‚úÖ Ceremony Finalized\n\nAutomated merge by Lambda-ZK Ceremony`
                });
                console.log('‚úÖ PR merged successfully using GITHUB_TOKEN');
              }
            } catch (error) {
              console.error('‚ùå Failed to merge finalization PR:', error.message);
              throw error;
            }
            console.log(`‚úÖ Finalization validation passed - merging PR #${prNumber}`);

            // Post a comment explaining the merge
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: `‚úÖ **Ceremony finalization validated and merged**

            **Validation Summary:**
            - ‚úÖ Drand randomness fetched and verified
            - ‚úÖ Beacon hash applied to ceremony chain
            - ‚úÖ Final zkey verified against R1CS and PTAU
            - ‚úÖ Verification key exported
            - ‚úÖ SHA-256 checksums generated

            **Status:**
            Automatically merging to complete the ceremony...

            ---
            ü§ñ Automated merge by Lambda-ZK Ceremony`
            });

            // Merge the PR using BYPASS_TOKEN (bypasses branch protection)
            console.log('üîÄ Merging PR...');

            try {
              const mergeResult = await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                merge_method: 'squash',
                commit_title: `[CEREMONY] Finalize with drand beacon (#${prNumber})`,
                commit_message: `‚úÖ Ceremony finalization complete

            Automated merge by Lambda-ZK Ceremony

            Validation Summary:
            - Drand randomness: VERIFIED
            - Beacon hash application: PASSED
            - Final zkey verification: PASSED
            - Verification key export: PASSED
            - Checksums: GENERATED

            Workflow run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`
              });

              console.log('‚úÖ PR merged successfully');
              console.log(`   SHA: ${mergeResult.data.sha}`);
              console.log(`   Merged: ${mergeResult.data.merged}`);

              // Delete the branch
              try {
                const branchName = `ceremony-finalize-${{ github.run_id }}`;
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `heads/${branchName}`
                });
                console.log('‚úÖ Branch deleted');
              } catch (deleteError) {
                console.log('‚ÑπÔ∏è  Could not delete branch:', deleteError.message);
              }

            } catch (mergeError) {
              console.error('‚ùå Failed to merge PR:', mergeError.message);

              // Post a comment about the merge failure
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `‚ö†Ô∏è **Automatic merge failed**

            The ceremony finalization has been **validated** and passed all checks, but automatic merge failed.

            **Error:** ${mergeError.message}

            **Action Required:**
            A repository maintainer needs to manually merge this PR.

            ---
            ü§ñ Automated validation by Lambda-ZK Ceremony`
              });

              throw mergeError; // Fail the workflow
            }
